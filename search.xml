<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[http协议(二) 实战]]></title>
    <url>%2F2015%2F03%2F13%2Fhttp%E5%8D%8F%E8%AE%AE(%E4%BA%8C)%20%E5%AE%9E%E6%88%98(python)%2F</url>
    <content type="text"><![CDATA[上篇文章简单介绍了下HTTP协议，但是说到HTTPS时，有一个重要的概念没说，就是HTTPS中的S，这个S指的是SSL/TLS协议。SSL是指Secure Sockets Layer，而TLS（Transport Layer Security）则是SSL的升级版。 不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息都是明文传播，这就带来了三大风险。 窃听风险（eavesdropping）：第三方可以获知通信内容。 篡改风险（tampering）：第三方可以修改通信内容。 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 SSL/TLS协议是为了解决这三大风险而设计的，希望达到： 所有信息都是加密传播，第三方无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 ​ 神图开篇 SSL/TLS的基本运行过程SSL/TLS协议和HTTP协议一样，都是在应用层 其基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 但是，这里有两个问题。 （1）如何保证公钥不被篡改？ 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 （2）公钥加密计算量太大，如何减少耗用的时间？ 解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 因此，SSL/TLS协议的基本过程是这样的： 客户端向服务器端索要并验证公钥。 双方协商生成”对话密钥”。 双方采用”对话密钥”进行加密通信。 上面过程的前两步，又称为”握手阶段”（handshake）。具体的握手阶段过程如下图 “握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。 这个握手阶段在TCP三次握手建立连接之后，再然后就是HTTP过程了，只不过内容是经过对话密钥加密过的。最后是TCP四次挥手断开连接（其他的略过不讲） 握手的四个阶段就不展开说了，需要知道的是，最后服务器端会返回一个会话密钥，如果是写爬虫，就少不了这么样一个参数 比如我要写知乎爬虫，报错 1requests.exceptions.SSLError: ("bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)",) 说的就是握手这个阶段出错了，怎么解决? 一个办法是登陆一次，记录下cookie等参数，或者就是直接在程序里面登录 实战下面python代码简单演示一个最基本的http/https客户端是应该如何写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184def parsed_url(url): """ 解析 url 返回 (protocol host port path) 有的时候有的函数, 它本身就美不起来, 你要做的就是老老实实写 """ # 检查协议 protocol = 'http' if url[:7] == 'http://': u = url.split('://')[1] elif url[:8] == 'https://': protocol = 'https' u = url.split('://')[1] else: # '://' 定位 然后取第一个 / 的位置来切片 u = url # https://g.cn:1234/hello # g.cn:1234/hello # 检查默认 path i = u.find('/') if i == -1: host = u path = '/' else: host = u[:i] path = u[i:] # 检查端口 port_dict = &#123; 'http': 80, 'https': 443, &#125; # 默认端口 port = port_dict[protocol] # if host.find(':') != -1: if ':' in host: h = host.split(':') host = h[0] port = int(h[1]) return protocol, host, port, pathdef socket_by_protocol(protocol): """ 根据协议返回一个 socket 实例 """ if protocol == 'http': s = socket.socket() else: # HTTPS 协议需要使用 ssl.wrap_socket 包装一下原始的 socket # 除此之外无其他差别 s = ssl.wrap_socket(socket.socket()) return sdef response_by_socket(s): """ 参数是一个 socket 实例 返回这个 socket 读取的所有数据 """ response = b'' buffer_size = 1024 while True: r = s.recv(buffer_size) if len(r) == 0: break response += r return responsedef parsed_response(r): """ 把 response 解析出 状态码 headers body 返回 状态码是 int headers 是 dict body 是 str """ header, body = r.split('\r\n\r\n', 1) h = header.split('\r\n') status_code = h[0].split()[1] status_code = int(status_code) headers = &#123;&#125; for line in h[1:]: k, v = line.split(': ') headers[k] = v return status_code, headers, body# 复杂的逻辑全部封装成函数def get(url): """ 用 GET 请求 url 并返回响应 """ protocol, host, port, path = parsed_url(url) # 写 what 不写 how s = socket_by_protocol(protocol) s.connect((host, port)) request = 'GET &#123;&#125; HTTP/1.1\r\nHost: &#123;&#125;\r\nConnection: close\r\n\r\n'.format(path, host) encoding = 'utf-8' s.send(request.encode(encoding)) response = response_by_socket(s) print('get response, ', response) r = response.decode(encoding) status_code, headers, body = parsed_response(r) if status_code in [301, 302]: url = headers['Location'] return get(url) return status_code, headers, bodydef main(): url = 'http://movie.douban.com/top250' status_code, headers, body = get(url) print('main', status_code) # print('main headers (&#123;&#125;)'.format(headers)) # print('main body', body)# 以下 test 开头的函数是单元测试def test_parsed_url(): """ parsed_url 函数很容易出错, 所以我们写测试函数来运行看检测是否正确运行 """ http = 'http' https = 'https' host = 'g.cn' path = '/' test_items = [ ('http://g.cn', (http, host, 80, path)), ('http://g.cn/', (http, host, 80, path)), ('http://g.cn:90', (http, host, 90, path)), ('http://g.cn:90/', (http, host, 90, path)), # ('https://g.cn', (https, host, 443, path)), ('https://g.cn:233/', (https, host, 233, path)), ] for t in test_items: url, expected = t u = parsed_url(url) # assert 是一个语句, 名字叫 断言 # 如果断言成功, 条件成立, 则通过测试 # 否则为测试失败, 中断程序报错 e = "parsed_url ERROR, (&#123;&#125;) (&#123;&#125;) (&#123;&#125;)".format(url, u, expected) assert u == expected, edef test_parsed_response(): """ 测试是否能正确解析响应 """ # NOTE, 行末的 \ 表示连接多行字符串 response = 'HTTP/1.1 301 Moved Permanently\r\n' \ 'Content-Type: text/html\r\n' \ 'Location: https://movie.douban.com/top250\r\n' \ 'Content-Length: 178\r\n\r\n' \ 'test body' status_code, header, body = parsed_response(response) assert status_code == 301 assert len(list(header.keys())) == 3 assert body == 'test body'def test_get(): """ 测试是否能正确处理 HTTP 和 HTTPS """ urls = [ 'http://movie.douban.com/top250', 'https://movie.douban.com/top250', ] # 这里就直接调用了 get 如果出错就会挂, 测试得比较简单 for u in urls: get(u)def test(): """ 用于测试的主函数 """ test_parsed_url() # test_get() # test_parsed_response()if __name__ == '__main__': # test() main() 从中很容易发现这一段根据协议返回HTTP或HTTPS的socket这段代码 1234567891011def socket_by_protocol(protocol): """ 根据协议返回一个 socket 实例 """ if protocol == 'http': s = socket.socket() else: # HTTPS 协议需要使用 ssl.wrap_socket 包装一下原始的 socket # 除此之外无其他差别 s = ssl.wrap_socket(socket.socket()) return s 这就是python的神奇之处了，一句话代码搞定]]></content>
      <categories>
        <category>basic</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http协议(一)HTTP和HTTPS概述]]></title>
    <url>%2F2015%2F03%2F11%2Fhttp%E5%8D%8F%E8%AE%AE(%E4%B8%80)%20http%E4%B8%8Ehttps%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[HTTP 协议是互联网的基础协议，也是web开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。下面看下HTTP需要掌握些啥 [TOC] 这种文章开头都先祭出这一张神图以供参考 HTTP协议到底是什么超文本传输协议（Hypertext Transfer Protocol，简称HTTP）是应用层协议。HTTP 是一种请求/响应式的协议，即一个客户端与服务器建立连接后，向服务器发送一个请求；服务器接到请求后，给予相应的响应信息。 HTTP 请求报文 http请求报文由请求行，请求头部，空行以及请求包体组成，如下图所示： 1、请求行 由请求方法，URL以及协议版本三部分组成，每个部分以空格分隔。常用的请求方法有：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT； GET：当客户端要从服务器中读取某个资源时，使用GET 方法。GET 方法要求服务器将URL 定位的资源放在响应报文的数据部分，回送给客户端，即向服务器请求某个资源。使用GET 方法时，请求参数和对应的值附加在 URL 后面，利用一个问号（“?”）代表URL 的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind。 POST：当客户端给服务器提供信息较多时可以使用POST 方法，POST 方法向服务器提交数据，比如完成表单数据的提交，将数据提交给服务器处理。GET 一般用于获取/查询资源信息，POST 会附带用户数据，一般用于更新资源信息。POST 方法将请求参数封装在HTTP 请求数据中，以名称/值的形式出现，可以传输大量数据； 2、请求头部请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有： User-Agent：产生请求的浏览器类型； Accept：客户端可识别的响应内容类型列表；星号 “ ” 用于按范围将类型分组，用 “ / ” 指示可接受全部类型，用“ type/ ”指示可接受 type 类型的所有子类型； Accept-Language：客户端可接受的自然语言； Accept-Encoding：客户端可接受的编码压缩格式； Accept-Charset：可接受的应答的字符集； Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机； connection：连接方式（close 或 keepalive）； Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie； 这么多个请求头参数中，Host是必须的，其他都是可选的 3、空行最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头； 4、请求体 请求体不在 GET 方法中使用，而是在POST 方法中使用。POST 方法适用于需要客户填写表单的场合。与请求体相关的最常使用的是类型 Content-Type 和长度 Content-Length； HTTP 响应报文HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。 常见的状态码有如下几种： 200 OK 客户端请求成功 301 Moved Permanently 请求永久重定向 302 Moved Temporarily 请求临时重定向 304 Not Modified 文件未修改，可以直接使用缓存的文件。 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 下面是一个HTTP响应的例子： 1234567HTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112&lt;html&gt;... 无状态性HTTP 协议是无状态的（stateless）。无状态是指协议对于事务处理没有记忆能力，也就是说，同一个客户端第二次访问同一个服务器上的页面时，服务器无法知道这个客户端曾经访问过，服务器也无法分辨不同的客户端。HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP 请求。 所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，所以HTTP是无状态连接。 短连接Http协议是建立在TCP协议基础之上的，TCP协议对应于传输层，而HTTP协议对应于应用层。 HTTP通讯过程是首先通过TCP建立起一个到服务器的连接通道（三次握手），当HTTP请求的数据传输完毕后，就会断开TCP连接（四次挥手）。这个过程是很短的，所以说HTTP是短连接。 但是现在默认是开启keep-alive以保持连接性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。当这个时间到了，还是会断开连接。 后来，通过Session, Cookie等相关技术，也能保持一些用户的状态。但是依然是无状态连接，原理不同罢。 会话跟踪 什么是会话？ 客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。 什么是会话跟踪？ 会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。 为什么需要会话跟踪？ 浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。 会话跟踪常用的方法: URL重写 URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。 隐藏表单域 将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示 Cookie Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用。 客户端可以采用两种方式来保存这个Cookie对象，一种方式是保存在客户端内存中，称为临时Cookie，浏览器关闭后这个Cookie对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久Cookie。以后客户端只要访问该网站，就会将这个Cookie再次发送到服务器上，前提是这个Cookie在有效期内，这样就实现了对客户的跟踪。 Cookie是可以被禁止的。 Session: 每一个用户都有一个不同的session，各个用户之间是不能共享的，是每个用户所独享的，在session中可以存放信息。 在服务器端会创建一个session对象，产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端，下一次访问时，sessionID会发送到服务器，在服务器端进行识别不同的用户。 Session的实现依赖于Cookie，如果Cookie被禁用，那么session也将失效。 HTTP 工作原理HTTP 协议采用请求/响应模型。客户端向服务器发送一个请求报文，服务器以一个状态作为响应。 以下是 HTTP 请求/响应的步骤： 客户端连接到web服务器：HTTP 客户端与web服务器建立一个 TCP 连接； 客户端向服务器发起 HTTP 请求：通过已建立的TCP 连接，客户端向服务器发送一个请求报文； 服务器接收 HTTP 请求并返回 HTTP 响应：服务器解析请求，定位请求资源，服务器将资源副本写到 TCP 连接，由客户端读取； 释放 TCP 连接：若connection 模式为close，则服务器主动关闭TCP 连接，客户端被动关闭连接，释放TCP 连接；若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求； 客户端浏览器解析HTML内容：客户端将服务器响应的 html 文本解析并显示； 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址； 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接； 浏览器发出读取文件（URL 中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器； 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器； 释放 TCP 连接； 浏览器将该 html 文本并显示内容; HTTPS又是啥HTTPS ，超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 协议层HTTP协议和安全协议同属于应用层（OSI模型的最高层），具体来讲，安全协议工作在HTTP之下，运输层之上：安全协议向运行HTTP的进程提供一个类似于TCP的套接字，供进程向其中注入报文，安全协议将报文加密并注入运输层套接字；或是从运输层获取加密报文，解密后交给对应的进程。严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。 HTTPS报文中的任何东西都被加密，包括所有报头和荷载。除了可能的选择密文攻击之外，一个攻击者所能知道的只有在两者之间有一连接这一事实。 与HTTP的差异 与HTTP的URL由“http://”起始且默认使用**端口**80**不同**，HTTPS的URL由“https://”起始且默认使用端口443。 HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。 http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。 https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。]]></content>
      <categories>
        <category>basic</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu上配置shadowsock服务端]]></title>
    <url>%2F2015%2F02%2F27%2Fconfig-ss(server)in-ubuntu%2F</url>
    <content type="text"><![CDATA[墙外的世界总是那么充满诱惑，本文就讲讲怎么在ubuntu上假设ss 服务端的安装与运行1. 安装 pip 环境通过 Putty 等软件登录 Linux 后，输入以下命令来安装 pip 环境： Ubuntu / Debian 1apt-get install python-pip CentOS 1yum install python-setuptools &amp;&amp; easy_install pip 在需要时输入 Y 后按回车确认。 2. 直接安装 shadowsocks1pip install shadowsocks 如果出现 Command &quot;python setup.py egg_info&quot; failed 错误信息，则输入 pip install --upgrade pip 命令后，再执行上面的操作。如果出现 Could not import setuptools which is required to install from a source distribution 错误信息，则输入 pip install setuptools 命令后，再执行上面的操作。 3. 配置并运行 shadowsocks1sudo ssserver -p 8388 -k password -m rc4-md5 -d start SS 端口默认为 8388；password 为自定义的登录密码；加密方式有 bf-cfb / aes-256-cfb / des-cfb /rc4 等可选，推荐使用 rc4-md5，因为 rc4-md5 比 aes-256-cfb 速度快好几倍。 至此，SS服务端已经配置完成了。 SS优化与加速1. 编辑文件 limits.conf确认 Linux 内核版本为 3.5 以上，可用 uname -a 命令查看。 关闭SS服务 1sudo ssserver -p 8388 -k password -m rc4-md5 -d stop 编辑文件 limits.conf 1vi /etc/security/limits.conf 增加以下两行 12* soft nofile 51200* hard nofile 51200 设置以下参数 1ulimit -n 51200 2. 调整内核参数修改配置文件 /etc/sysctl.conf 1vi /etc/sysctl.conf 加入以下内容 1234567891011121314151617181920fs.file-max = 51200net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.core.netdev_max_backlog = 250000net.core.somaxconn = 4096net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 0net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 1200net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 8192net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_fastopen = 3net.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = hybla 修改后执行 sysctl -p 使配置生效，并重新 start SS 服务。]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>shadowsock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈CSRF漏洞]]></title>
    <url>%2F2015%2F02%2F22%2Fwhat-is-csrf%2F</url>
    <content type="text"><![CDATA[CSRF概念​ 先说说什么是CSRF（Cross—Site Request Forgery），顾名思义，跨站请求伪造，也就是：攻击者盗用了你的身份，以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 CSRF原理过程​ 假设Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。进行CSRF攻击的原理及过程如下： 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 举个栗子 ​ 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。 ​ 黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。 ​ 这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 CSRF漏洞如何检测​ 检测CSRF漏洞是一个繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，就说明确定存在有CSRF漏洞 ​ 现在也有不少黑客工具可以专门针对CSRF漏洞进行检测CSRFTester，CSRF Request Builder等。 ​ 以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行检测时，首先抓取我们在浏览器中访问的所有连接以及所有表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这就相当于一次伪造客户顿的请求，如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞。 如何防御CSRF攻击​ 目前防御CSRF攻击主要有三个策略：验证HTTP Referer字段；在请求中加入token并验证；在HTTP头中加入自定义属性并验证。 验证 HTTP Referer 字段 ​这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。 ​然而，这意味着把安全性都依赖于第三方（也就是浏览器）来实现，因为Referer的值是有浏览器提供的，理论上说并不安全，因为有一些方法可以篡改浏览器赋给请求的 Referer 值 在请求地址中添加 token 并验证 ​现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。 例子： 用户访问某个表单页面。 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。 在页面表单附带上Token参数。 用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。 ​ 这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。 ​ 注意：CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。 在 HTTP 头中自定义属性并验证 ​ 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 ​ 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
        <tag>安全</tag>
      </tags>
  </entry>
</search>
